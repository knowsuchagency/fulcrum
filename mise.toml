[env]
_.file = ".env"
# Default FULCRUM_DIR for dev - can be overridden via env var before running mise
FULCRUM_DIR = "{{ env.FULCRUM_DIR | default(value='~/tmp/fulcrum') }}"

[tools]
bun = "latest"

[hooks.postinstall]
run = "bun install"

[tasks.install]
description = "Install dependencies"
run = "bun install"

[tasks.bump]
description = "Bump version (major, minor, or patch)"
usage = '''
arg "[type]" help="Version type: major, minor, or patch" default="patch"
flag "-c" "--commit" help="Auto-commit after bumping"
'''
run = """
#!/usr/bin/env bash
set -e
current=$(jq -r '.version' package.json)
IFS='.' read -r major minor patch <<< "$current"

case "${usage_type}" in
  major) major=$((major + 1)); minor=0; patch=0 ;;
  minor) minor=$((minor + 1)); patch=0 ;;
  patch) patch=$((patch + 1)) ;;
  *) echo "Invalid type: ${usage_type}. Use major, minor, or patch" >&2; exit 1 ;;
esac

new_version="$major.$minor.$patch"

# Update package.json
jq --arg v "$new_version" '.version = $v' package.json > package.json.tmp && mv package.json.tmp package.json
echo "Updated package.json: $current → $new_version"

# Update plugin marketplace.json
marketplace=".claude-plugin/marketplace.json"
if [ -f "$marketplace" ]; then
  jq --arg v "$new_version" '.plugins[0].version = $v' "$marketplace" > "${marketplace}.tmp" && mv "${marketplace}.tmp" "$marketplace"
  echo "Updated $marketplace"
fi

# Update plugin.json
plugin="plugins/fulcrum/.claude-plugin/plugin.json"
if [ -f "$plugin" ]; then
  jq --arg v "$new_version" '.version = $v' "$plugin" > "${plugin}.tmp" && mv "${plugin}.tmp" "$plugin"
  echo "Updated $plugin"
fi

# Update plugin marketplace.json (installed plugin)
plugin_marketplace="plugins/fulcrum/.claude-plugin/marketplace.json"
if [ -f "$plugin_marketplace" ]; then
  jq --arg v "$new_version" '.plugins[0].version = $v' "$plugin_marketplace" > "${plugin_marketplace}.tmp" && mv "${plugin_marketplace}.tmp" "$plugin_marketplace"
  echo "Updated $plugin_marketplace"
fi

# Update neutralino.config.json
neutralino_config="desktop/neutralino.config.json"
if [ -f "$neutralino_config" ]; then
  jq --arg v "$new_version" '.version = $v | .globalVariables.APP_VERSION = $v' "$neutralino_config" > "${neutralino_config}.tmp" && mv "${neutralino_config}.tmp" "$neutralino_config"
  echo "Updated $neutralino_config"
fi

# Update settings schema version to match major version
settings_file="server/lib/settings.ts"
if [ -f "$settings_file" ]; then
  current_schema=$(grep '^const CURRENT_SCHEMA_VERSION' "$settings_file" | sed 's/.*= //')
  if [ -n "$current_schema" ] && [ "$current_schema" != "$major" ]; then
    # Use perl for cross-platform compatibility (macOS sed -i differs from GNU sed)
    perl -i -pe "s/CURRENT_SCHEMA_VERSION = $current_schema/CURRENT_SCHEMA_VERSION = $major/" "$settings_file"
    echo "Updated $settings_file: schema $current_schema → $major"
  fi
fi

# Update MCP server versions
mcp_http="server/routes/mcp.ts"
if [ -f "$mcp_http" ]; then
  perl -i -pe "s/version: '[0-9]+\\.[0-9]+\\.[0-9]+'/version: '$new_version'/" "$mcp_http"
  echo "Updated $mcp_http"
fi

mcp_stdio="cli/src/mcp/index.ts"
if [ -f "$mcp_stdio" ]; then
  perl -i -pe "s/version: '[0-9]+\\.[0-9]+\\.[0-9]+'/version: '$new_version'/" "$mcp_stdio"
  echo "Updated $mcp_stdio"
fi

echo "Bumped version: $current → $new_version"

# Auto-commit if --commit flag is set
if [ "$usage_commit" = "true" ]; then
  git add -A
  git commit -m "chore: bump version to $new_version"
  echo "Committed version bump"
fi
"""

[tasks.dev]
description = "Start frontend and backend dev servers"
depends = ["install"]
usage = 'flag "--host" help="Bind to all network interfaces (0.0.0.0)"'
run = """
# Ensure child processes are killed when this script exits
cleanup() {
  # Kill entire process group
  kill -- -$$ 2>/dev/null || true
}
trap cleanup EXIT INT TERM

FULCRUM_DIR="${FULCRUM_DIR:-$HOME/tmp/fulcrum}"

# Default dev port to 8888 (prod uses 7777), respect PORT env var if set
# Note: 6666 might conflict with 'cbt' (SSH tunnel) service on some systems.
# If you encounter "Address already in use", set PORT=8888 or similar in .env
PORT="${PORT:-8888}"

# Determine host binding
if [ "$usage_host" = "true" ]; then
  VITE_HOST="--host"
else
  VITE_HOST=""
fi
VITE_BACKEND_PORT="$PORT"
DEBUG="1"
# Pass through env vars explicitly since they may not inherit through concurrently/bunx
# --kill-others ensures if one process dies, all are killed
bunx concurrently --kill-others -n server,client -c blue,green \
  "FULCRUM_DIR=$FULCRUM_DIR PORT=$PORT mise run server" \
  "DEBUG=$DEBUG VITE_BACKEND_PORT=$VITE_BACKEND_PORT VITE_HOST=$VITE_HOST mise run client"
"""

[tasks.server]
description = "Start backend dev server with auto-reload"
run = """
mkdir -p "${FULCRUM_DIR:-$HOME/.fulcrum}"

# Install OpenCode plugin from source (dev mode - always fresh)
OPENCODE_PLUGIN_DIR="$HOME/.config/opencode/plugin"
mkdir -p "$OPENCODE_PLUGIN_DIR"
cp plugins/fulcrum-opencode/index.ts "$OPENCODE_PLUGIN_DIR/fulcrum.ts"
echo "Installed OpenCode plugin from source" >&2

bun --watch server/index.ts
"""

[tasks.client]
description = "Start frontend dev server"
run = "DEBUG=\"${DEBUG:-}\" bunx vite --port \"${FRONTEND_PORT:-5173}\" ${VITE_HOST:-}"

[tasks.build]
description = "Build for production"
depends = ["install"]
run = """
rm -rf dist
bunx drizzle-kit generate
bunx tsc -b --force && bunx vite build
"""

[tasks."build:debug"]
description = "Build for production with debug logging enabled"
run = """
rm -rf dist
bunx drizzle-kit generate
bunx tsc -b --force && DEBUG=1 bunx vite build
"""

[tasks.start]
description = "Run production server"
depends = ["build"]
usage = 'flag "--host" help="Bind to all network interfaces (0.0.0.0)"'
run = """
if [ "$usage_host" = "true" ]; then
  HOST="0.0.0.0"
else
  HOST="localhost"
fi
NODE_ENV=production HOST="$HOST" bun server/index.ts
"""

[tasks.test]
description = "Run linter and all tests (quiet mode, errors only)"
usage = 'flag "-v" "--verbose" help="Show all test output"'
run = """
#!/usr/bin/env bash
set -e
set -o pipefail

# Run linter first (doesn't need isolation)
echo "Running linter..." >&2
bunx eslint . || exit 1

# Create isolated test directories BEFORE bun starts.
# This is critical because Bun caches os.homedir() at process startup,
# before any JavaScript runs (including preload scripts).
# Setting HOME here ensures the cached value is the temp directory.
#
# HOME_BACKUP preserves the original HOME so test isolation code can
# detect and block access to production paths (~/.fulcrum, ~/.claude).
export HOME_BACKUP="$HOME"
export HOME=$(mktemp -d -t fulcrum-test-home-XXXXXX)
export FULCRUM_DIR=$(mktemp -d -t fulcrum-test-dir-XXXXXX)
echo "[test] Isolated environment: HOME=$HOME FULCRUM_DIR=$FULCRUM_DIR" >&2

# Run tests serially to avoid env var conflicts between test files
echo "Running tests..." >&2
if [ "$usage_verbose" = "true" ]; then
  bun test --max-concurrency=1
else
  # Filter to show only failures and summary (exclude diff lines starting with +/-)
  bun test --max-concurrency=1 2>&1 | grep -v '^[+-]' | grep -E '(^bun test|[(]fail[)]|✗|expect[(]received[)]|^ *[0-9]+ (pass|fail|skip)|^Ran [0-9]+ tests)' || [ ${PIPESTATUS[0]} -eq 0 ]
fi
"""

[tasks."test:file"]
description = "Run specific test file(s) with isolation"
usage = 'arg "<files>..." help="Test file paths"'
run = """
#!/usr/bin/env bash
set -e

# Create isolated test directories before bun starts
# HOME_BACKUP preserves the original HOME for test isolation checks
export HOME_BACKUP="$HOME"
export HOME=$(mktemp -d -t fulcrum-test-home-XXXXXX)
export FULCRUM_DIR=$(mktemp -d -t fulcrum-test-dir-XXXXXX)
echo "[test:file] Isolated environment: HOME=$HOME FULCRUM_DIR=$FULCRUM_DIR" >&2

bun test ${usage_files}
"""

[tasks."test:watch"]
description = "Run tests in watch mode (with isolation)"
run = """
#!/usr/bin/env bash
set -e

# Create isolated test directories before bun starts
# HOME_BACKUP preserves the original HOME for test isolation checks
export HOME_BACKUP="$HOME"
export HOME=$(mktemp -d -t fulcrum-test-home-XXXXXX)
export FULCRUM_DIR=$(mktemp -d -t fulcrum-test-dir-XXXXXX)
echo "[test:watch] Isolated environment: HOME=$HOME FULCRUM_DIR=$FULCRUM_DIR" >&2

bun test --watch
"""

[tasks.lint]
description = "Run ESLint"
run = "bunx eslint ."

[tasks.typecheck]
description = "Check TypeScript types"
run = "bunx tsc --noEmit"

[tasks.check]
description = "Run all checks (lint + typecheck + version)"
depends = ["lint", "typecheck", "check:version"]

[tasks."check:version"]
description = "Verify all version files are in sync"
run = """
#!/usr/bin/env bash
set -e

# Source of truth
VERSION=$(jq -r '.version' package.json)

# Files to check
MARKETPLACE=".claude-plugin/marketplace.json"
PLUGIN="plugins/fulcrum/.claude-plugin/plugin.json"
NEUTRALINO="desktop/neutralino.config.json"

errors=0

# Check marketplace.json
if [ -f "$MARKETPLACE" ]; then
  MARKETPLACE_VERSION=$(jq -r '.plugins[0].version' "$MARKETPLACE")
  if [ "$MARKETPLACE_VERSION" != "$VERSION" ]; then
    echo "ERROR: $MARKETPLACE version ($MARKETPLACE_VERSION) != package.json ($VERSION)" >&2
    errors=$((errors + 1))
  fi
fi

# Check plugin.json
if [ -f "$PLUGIN" ]; then
  PLUGIN_VERSION=$(jq -r '.version' "$PLUGIN")
  if [ "$PLUGIN_VERSION" != "$VERSION" ]; then
    echo "ERROR: $PLUGIN version ($PLUGIN_VERSION) != package.json ($VERSION)" >&2
    errors=$((errors + 1))
  fi
fi

# Check plugin marketplace.json
PLUGIN_MARKETPLACE="plugins/fulcrum/.claude-plugin/marketplace.json"
if [ -f "$PLUGIN_MARKETPLACE" ]; then
  PLUGIN_MARKETPLACE_VERSION=$(jq -r '.plugins[0].version' "$PLUGIN_MARKETPLACE")
  if [ "$PLUGIN_MARKETPLACE_VERSION" != "$VERSION" ]; then
    echo "ERROR: $PLUGIN_MARKETPLACE version ($PLUGIN_MARKETPLACE_VERSION) != package.json ($VERSION)" >&2
    errors=$((errors + 1))
  fi
fi

# Check neutralino.config.json (has two version fields)
if [ -f "$NEUTRALINO" ]; then
  NL_VERSION=$(jq -r '.version' "$NEUTRALINO")
  NL_APP_VERSION=$(jq -r '.globalVariables.APP_VERSION' "$NEUTRALINO")

  if [ "$NL_VERSION" != "$VERSION" ]; then
    echo "ERROR: $NEUTRALINO .version ($NL_VERSION) != package.json ($VERSION)" >&2
    errors=$((errors + 1))
  fi

  if [ "$NL_APP_VERSION" != "$VERSION" ]; then
    echo "ERROR: $NEUTRALINO .globalVariables.APP_VERSION ($NL_APP_VERSION) != package.json ($VERSION)" >&2
    errors=$((errors + 1))
  fi
fi

if [ $errors -gt 0 ]; then
  echo "" >&2
  echo "Version mismatch detected! Run 'mise run bump' to sync all versions." >&2
  exit 1
fi

echo "All versions in sync: $VERSION"

# Show schema version (informational)
if [ -f "server/lib/settings.ts" ]; then
  SCHEMA_VERSION=$(grep '^const CURRENT_SCHEMA_VERSION' server/lib/settings.ts | sed 's/.*= //')
  echo "Settings schema version: $SCHEMA_VERSION"
fi
"""

[tasks.preview]
description = "Preview production build"
run = "bunx vite preview"

[tasks."db:studio"]
description = "Open Drizzle Studio GUI"
run = "bun run drizzle-kit studio"

[tasks."db:generate"]
description = "Generate migrations"
raw = true  # drizzle-kit may prompt for table rename decisions
run = "bun run drizzle-kit generate"

[tasks."db:migrate"]
description = "Apply migrations"
run = "bun run drizzle-kit migrate"

# CLI tasks
[tasks."cli"]
description = "Run CLI command"
usage = 'arg "[args]..." help="Arguments to pass to CLI" default=""'
run = "bun cli/src/index.ts ${usage_args}"

[tasks."cli:link"]
description = "Link CLI for global access"
dir = "cli"
run = "bun link"

[tasks."cli:typecheck"]
description = "Typecheck CLI"
run = "bunx tsc --noEmit -p cli/tsconfig.json"

[tasks."cli:bundle"]
description = "Bundle CLI package for npm distribution"
depends = ["build"]
run = """
set -e

# Generate cli/package.json from root package.json
echo "Generating cli/package.json..." >&2
jq '{
  name,
  version,
  description,
  license,
  repository: {type: "git", url: "https://github.com/knowsuchagency/fulcrum"},
  homepage: "https://github.com/knowsuchagency/fulcrum",
  type: "module",
  bin: {fulcrum: "bin/fulcrum.js"},
  files: ["bin/", "server/", "lib/", "dist/", "drizzle/", "README.md", "LICENSE"],
  engines: {bun: ">=1.0.0"}
}' package.json > cli/package.json

# Bundle server
echo "Bundling server..." >&2
bun build server/index.ts --target=bun --outfile=cli/server/index.js

# Bundle CLI with node shebang
echo "Bundling CLI..." >&2
mkdir -p cli/bin
bun build cli/src/index.ts --target=bun --outfile=cli/bin/fulcrum.js
# Replace bun shebang with node (npm requirement) - bun is still invoked at runtime
# Use perl for cross-platform compatibility (macOS sed -i differs from GNU sed)
perl -i -pe 's|#!/usr/bin/env bun|#!/usr/bin/env node| if $. == 1' cli/bin/fulcrum.js

# Copy native PTY libraries (all platforms)
echo "Copying native PTY libraries..." >&2
mkdir -p cli/lib
cp node_modules/bun-pty/rust-pty/target/release/librust_pty.so cli/lib/ 2>/dev/null || true
cp node_modules/bun-pty/rust-pty/target/release/librust_pty_arm64.so cli/lib/ 2>/dev/null || true
cp node_modules/bun-pty/rust-pty/target/release/librust_pty.dylib cli/lib/ 2>/dev/null || true
cp node_modules/bun-pty/rust-pty/target/release/librust_pty_arm64.dylib cli/lib/ 2>/dev/null || true
cp node_modules/bun-pty/rust-pty/target/release/rust_pty.dll cli/lib/ 2>/dev/null || true

# Generate SQL migrations
echo "Generating migrations..." >&2
bunx drizzle-kit generate
mkdir -p cli/drizzle
cp -r drizzle/* cli/drizzle/

# Copy frontend build
echo "Copying frontend build..." >&2
mkdir -p cli/dist
cp -r dist/* cli/dist/

# Copy README and LICENSE
echo "Copying README and LICENSE..." >&2
cp README.md cli/
cp LICENSE cli/

echo "CLI bundle complete"
"""

[tasks."cli:build"]
description = "Build CLI package for npm distribution"
depends = ["cli:bundle"]

[tasks."cli:publish"]
description = "Publish CLI to npm"
depends = ["cli:build"]
dir = "cli"
usage = 'arg "<otp>" help="npm one-time password for 2FA"'
run = "npm publish --access public --otp=${usage_otp}"

# Migration task
[tasks.migrate-from-vibora]
description = "Migrate data from ~/.vibora to ~/.fulcrum"
usage = 'flag "-y" "--yes" help="Auto-confirm prompts"'
run = """
if [ "$usage_yes" = "true" ]; then
  bun cli/src/index.ts migrate-from-vibora --yes
else
  bun cli/src/index.ts migrate-from-vibora
fi
"""

# Production daemon tasks
[tasks.up]
description = "Build and start production server as daemon"
depends = ["install", "build"]
usage = 'flag "--host" help="Bind to all network interfaces (0.0.0.0)"'
run = """
set -e

FULCRUM_DIR="${FULCRUM_DIR:-$HOME/.fulcrum}"
PID_FILE="$FULCRUM_DIR/fulcrum.pid"
SETTINGS_FILE="$FULCRUM_DIR/settings.json"

# Determine host binding
if [ "$usage_host" = "true" ]; then
  HOST="0.0.0.0"
else
  HOST="localhost"
fi

# Determine port: env var > settings.json > default 7777
if [ -z "$PORT" ]; then
  if [ -f "$SETTINGS_FILE" ] && command -v jq >/dev/null 2>&1; then
    # Try nested format first, fall back to flat
    PORT=$(jq -r '.server.port // .port // empty' "$SETTINGS_FILE" 2>/dev/null)
  fi
  PORT="${PORT:-7777}"
fi

# Check if already running
if [ -f "$PID_FILE" ]; then
  PID=$(cat "$PID_FILE")
  if kill -0 "$PID" 2>/dev/null; then
    echo "Fulcrum already running (PID: $PID)" >&2
    exit 1
  fi
fi

# Start server in background (server handles migrations on startup)
echo "Starting server..." >&2
mkdir -p "$FULCRUM_DIR"
nohup env NODE_ENV=production PORT="$PORT" HOST="$HOST" bun server/index.ts \
  > "$FULCRUM_DIR/server.log" 2>&1 &
PID=$!

# Write PID file
echo "$PID" > "$PID_FILE"

# Verify it started
sleep 1
if ! kill -0 "$PID" 2>/dev/null; then
  echo "Server failed to start. Check $FULCRUM_DIR/server.log" >&2
  rm -f "$PID_FILE"
  exit 1
fi

echo "Fulcrum started on http://localhost:$PORT (PID: $PID)"
"""

[tasks.down]
description = "Stop the daemon server"
run = """
PID_FILE="${FULCRUM_DIR:-$HOME/.fulcrum}/fulcrum.pid"
if [ ! -f "$PID_FILE" ]; then
  echo "No PID file found" >&2
  exit 1
fi

PID=$(cat "$PID_FILE")
if kill -0 "$PID" 2>/dev/null; then
  kill "$PID"
  echo "Stopped Fulcrum (PID: $PID)"
else
  echo "Process not running"
fi
rm -f "$PID_FILE"
"""

[tasks.restart]
description = "Restart fulcrum systemd service"
depends = ["cli:build"]
run = """
set -e

echo "Linking CLI..." >&2
cd cli && bun link && cd ..

echo "Restarting fulcrum (server handles migrations on startup)..." >&2
systemctl --user restart fulcrum

echo "Done. Checking status..." >&2
systemctl --user status fulcrum --no-pager
"""

# Desktop app tasks (client-only, connects to local or remote Fulcrum server)
[tasks."desktop:setup"]
description = "Install Neutralinojs CLI and dependencies"
run = """
set -e

# Check if neu CLI is installed
if ! command -v neu &> /dev/null; then
  echo "Installing Neutralinojs CLI..." >&2
  npm install -g @neutralinojs/neu
fi

# Neutralino binaries are vendored in git - just use them
cd desktop
echo "Using vendored Neutralino binaries" >&2

echo "Neutralinojs setup complete"
"""

[tasks."desktop:build"]
description = "Build desktop client app for current platform"
depends = ["desktop:setup", "desktop:bundle"]
run = """
set -e

cd desktop

echo "Building Neutralino app..." >&2
neu build

echo ""
echo "Desktop app built successfully!"
echo "Binaries are in: desktop/dist/"
echo ""
echo "The app will connect to a Fulcrum server running locally or remotely."
"""

[tasks."desktop:run"]
description = "Run desktop app in development mode"
depends = ["desktop:setup"]
run = """
cd desktop
neu run
"""

[tasks."desktop:dev"]
description = "Run desktop app pointing to dev server (port 5173)"
depends = ["desktop:setup"]
run = """
cd desktop
neu run -- --dev
"""

[tasks."desktop:bundle"]
description = "Bundle server and plugin for desktop app"
depends = ["build"]
usage = 'arg "[arch]" help="Architecture: x64 or arm64" default=""'
run = """
set -e

BUNDLE_DIR="desktop/bundle"
rm -rf "$BUNDLE_DIR"
mkdir -p "$BUNDLE_DIR/server" "$BUNDLE_DIR/lib" "$BUNDLE_DIR/drizzle" "$BUNDLE_DIR/dist" "$BUNDLE_DIR/plugin"

# Determine architecture and target
ARCH="${usage_arch}"
if [ -z "$ARCH" ]; then
  case "$(uname -m)" in
    arm64|aarch64) ARCH="arm64" ;;
    *) ARCH="x64" ;;
  esac
fi

# Determine target for bun compile
case "$(uname -s)" in
  Darwin*) TARGET="bun-darwin-${ARCH}" ;;
  Linux*) TARGET="bun-linux-${ARCH}" ;;
  *) echo "Unsupported platform" >&2; exit 1 ;;
esac

# Compile server as standalone executable (includes Bun runtime)
echo "Compiling server for ${TARGET}..." >&2
bun build server/index.ts --compile --target="${TARGET}" --outfile="$BUNDLE_DIR/server/fulcrum-server"
chmod +x "$BUNDLE_DIR/server/fulcrum-server"

# Copy native PTY libraries
echo "Copying native PTY libraries..." >&2
cp node_modules/bun-pty/rust-pty/target/release/librust_pty.so "$BUNDLE_DIR/lib/" 2>/dev/null || true
cp node_modules/bun-pty/rust-pty/target/release/librust_pty_arm64.so "$BUNDLE_DIR/lib/" 2>/dev/null || true
cp node_modules/bun-pty/rust-pty/target/release/librust_pty.dylib "$BUNDLE_DIR/lib/" 2>/dev/null || true
cp node_modules/bun-pty/rust-pty/target/release/librust_pty_arm64.dylib "$BUNDLE_DIR/lib/" 2>/dev/null || true
cp node_modules/bun-pty/rust-pty/target/release/rust_pty.dll "$BUNDLE_DIR/lib/" 2>/dev/null || true

# Generate and copy migrations
echo "Generating migrations..." >&2
bunx drizzle-kit generate
cp -r drizzle/* "$BUNDLE_DIR/drizzle/"

# Copy frontend build
echo "Copying frontend build..." >&2
cp -r dist/* "$BUNDLE_DIR/dist/"

# Copy Claude plugin (including hidden .claude-plugin directory)
echo "Copying Claude plugin..." >&2
cp -r plugins/fulcrum/. "$BUNDLE_DIR/plugin/"

# Copy package.json for version info (desktop app derives schema version from major version)
echo "Copying package.json..." >&2
cp package.json "$BUNDLE_DIR/"

echo "Desktop bundle created at $BUNDLE_DIR (standalone executable, no Bun required)"
"""

[tasks."desktop:bundle:debug"]
description = "Bundle server and plugin for desktop app with debug logging"
depends = ["build:debug"]
usage = 'arg "[arch]" help="Architecture: x64 or arm64" default=""'
run = """
set -e

BUNDLE_DIR="desktop/bundle"
rm -rf "$BUNDLE_DIR"
mkdir -p "$BUNDLE_DIR/server" "$BUNDLE_DIR/lib" "$BUNDLE_DIR/drizzle" "$BUNDLE_DIR/dist" "$BUNDLE_DIR/plugin"

# Determine architecture and target
ARCH="${usage_arch}"
if [ -z "$ARCH" ]; then
  case "$(uname -m)" in
    arm64|aarch64) ARCH="arm64" ;;
    *) ARCH="x64" ;;
  esac
fi

# Determine target for bun compile
case "$(uname -s)" in
  Darwin*) TARGET="bun-darwin-${ARCH}" ;;
  Linux*) TARGET="bun-linux-${ARCH}" ;;
  *) echo "Unsupported platform" >&2; exit 1 ;;
esac

# Compile server as standalone executable (includes Bun runtime)
echo "Compiling server for ${TARGET} (DEBUG)..." >&2
bun build server/index.ts --compile --target="${TARGET}" --outfile="$BUNDLE_DIR/server/fulcrum-server"
chmod +x "$BUNDLE_DIR/server/fulcrum-server"

# Copy native PTY libraries
echo "Copying native PTY libraries..." >&2
cp node_modules/bun-pty/rust-pty/target/release/librust_pty.so "$BUNDLE_DIR/lib/" 2>/dev/null || true
cp node_modules/bun-pty/rust-pty/target/release/librust_pty_arm64.so "$BUNDLE_DIR/lib/" 2>/dev/null || true
cp node_modules/bun-pty/rust-pty/target/release/librust_pty.dylib "$BUNDLE_DIR/lib/" 2>/dev/null || true
cp node_modules/bun-pty/rust-pty/target/release/librust_pty_arm64.dylib "$BUNDLE_DIR/lib/" 2>/dev/null || true
cp node_modules/bun-pty/rust-pty/target/release/rust_pty.dll "$BUNDLE_DIR/lib/" 2>/dev/null || true

# Generate and copy migrations
echo "Generating migrations..." >&2
bunx drizzle-kit generate
cp -r drizzle/* "$BUNDLE_DIR/drizzle/"

# Copy frontend build (with debug logging)
echo "Copying frontend build (DEBUG)..." >&2
cp -r dist/* "$BUNDLE_DIR/dist/"

# Copy Claude plugin (including hidden .claude-plugin directory)
echo "Copying Claude plugin..." >&2
cp -r plugins/fulcrum/. "$BUNDLE_DIR/plugin/"

# Copy package.json for version info (desktop app derives schema version from major version)
echo "Copying package.json..." >&2
cp package.json "$BUNDLE_DIR/"

echo "Desktop DEBUG bundle created at $BUNDLE_DIR"
"""

[tasks."desktop:build:debug"]
description = "Build desktop client app with debug logging"
depends = ["desktop:setup", "desktop:bundle:debug"]
run = """
set -e

cd desktop

echo "Building Neutralino app (DEBUG)..." >&2
neu build

echo ""
echo "Desktop DEBUG app built successfully!"
echo "Binaries are in: desktop/dist/"
"""

[tasks."desktop:clean"]
description = "Clean desktop build artifacts"
run = """
rm -rf desktop/dist
rm -rf desktop/bin
rm -rf desktop/bundle
echo "Desktop build artifacts cleaned"
"""

[tasks."desktop:clean-packages"]
description = "Remove old DMG and AppImage packages"
run = """
rm -f desktop/dist/*.dmg desktop/dist/*.AppImage
echo "Removed old packages from desktop/dist/"
"""

[tasks."desktop:package-appimage"]
description = "Package desktop app as AppImage (Linux)"
depends = ["desktop:build", "desktop:clean-packages"]
usage = 'arg "[arch]" help="Architecture: x64 or arm64" default="x64"'
run = """
./desktop/scripts/package-appimage.sh "${usage_arch}"
"""

[tasks."desktop:package-dmg"]
description = "Package desktop app as DMG (macOS)"
depends = ["desktop:build", "desktop:clean-packages"]
usage = 'arg "[arch]" help="Architecture: x64 or arm64" default=""'
run = """
./desktop/scripts/package-dmg.sh "${usage_arch}"
"""

[tasks."desktop:package-dmg:debug"]
description = "Package desktop app as DMG with debug logging (macOS)"
depends = ["desktop:build:debug", "desktop:clean-packages"]
usage = 'arg "[arch]" help="Architecture: x64 or arm64" default=""'
run = """
./desktop/scripts/package-dmg.sh "${usage_arch}"
"""

[tasks."desktop:package"]
description = "Package desktop app for current platform"
depends = ["desktop:build", "desktop:clean-packages"]
run = """
set -e

case "$(uname -s)" in
  Linux*)
    if [ "$(uname -m)" = "aarch64" ]; then
      ./desktop/scripts/package-appimage.sh arm64
    else
      ./desktop/scripts/package-appimage.sh x64
    fi
    ;;
  Darwin*)
    if [ "$(uname -m)" = "arm64" ]; then
      ./desktop/scripts/package-dmg.sh arm64
    else
      ./desktop/scripts/package-dmg.sh x64
    fi
    ;;
  *)
    echo "Packaging not supported on this platform"
    exit 1
    ;;
esac
"""

[tasks."desktop:manifest"]
description = "Generate update manifest.json for testing"
run = """
set -e
VERSION=$(jq -r '.version' package.json)
REPO="knowsuchagency/fulcrum"

mkdir -p desktop/dist
cat > desktop/dist/manifest.json << EOF
{
  "applicationId": "io.fulcrum.desktop",
  "version": "${VERSION}",
  "platforms": {
    "darwin-arm64": {
      "url": "https://github.com/${REPO}/releases/download/v${VERSION}/Fulcrum-${VERSION}-macos-arm64.dmg"
    },
    "linux-x64": {
      "url": "https://github.com/${REPO}/releases/download/v${VERSION}/Fulcrum-${VERSION}-linux-x64.AppImage"
    }
  }
}
EOF

echo "Generated manifest.json for version $VERSION"
cat desktop/dist/manifest.json
"""

[tasks."opencode:install"]
description = "Install OpenCode plugin from source"
run = """
OPENCODE_PLUGIN_DIR="$HOME/.config/opencode/plugin"
mkdir -p "$OPENCODE_PLUGIN_DIR"
cp plugins/fulcrum-opencode/index.ts "$OPENCODE_PLUGIN_DIR/fulcrum.ts"
echo "Installed OpenCode plugin at $OPENCODE_PLUGIN_DIR/fulcrum.ts"
echo "Restart OpenCode to load the updated plugin."
"""

[tasks."desktop:release"]
description = "Build all desktop packages for current platform"
depends = ["check:version", "desktop:build"]
run = """
set -e
case "$(uname -s)" in
  Darwin*)
    echo "Building macOS package..."
    ./desktop/scripts/package-dmg.sh arm64
    ;;
  Linux*)
    echo "Building Linux package..."
    ./desktop/scripts/package-appimage.sh x64
    ;;
esac
mise run desktop:manifest
echo "Desktop release packages ready in desktop/dist/"
"""

# Worker tasks
[tasks."worker:deploy"]
description = "Deploy fulcrum-utils Cloudflare worker"
dir = "fulcrum-utils"
run = "bun run deploy"
