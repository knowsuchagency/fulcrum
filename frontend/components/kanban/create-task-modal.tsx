import { useState, useEffect, useMemo, useRef } from 'react'
import { useNavigate } from '@tanstack/react-router'
import { useTranslation } from 'react-i18next'
import { toast } from 'sonner'
import { useHotkeys } from '@/hooks/use-hotkeys'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogClose,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { DescriptionTextarea } from '@/components/ui/description-textarea'
import { Field, FieldGroup, FieldLabel, FieldDescription } from '@/components/ui/field'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { Tabs, TabsList, TabsTrigger, TabsContent } from '@/components/ui/tabs'
import {
  Combobox,
  ComboboxInput,
  ComboboxContent,
  ComboboxList,
  ComboboxItem,
  ComboboxEmpty,
} from '@/components/ui/combobox'
import { HugeiconsIcon } from '@hugeicons/react'
import { TaskAdd01Icon, Folder01Icon, Cancel01Icon, Attachment01Icon } from '@hugeicons/core-free-icons'
import { ToggleGroup, ToggleGroupItem } from '@/components/ui/toggle-group'
import { useCreateTask } from '@/hooks/use-tasks'
import { useBranches, checkIsGitRepo } from '@/hooks/use-filesystem'
import { useWorktreeBasePath, useDefaultGitReposDir, useDefaultAgent, useOpencodeModel } from '@/hooks/use-config'
import { AGENT_DISPLAY_NAMES, type AgentType } from '@/types'
import { useRepositories } from '@/hooks/use-repositories'
import { useProjects } from '@/hooks/use-projects'
import { FilesystemBrowser } from '@/components/ui/filesystem-browser'
import { DatePickerPopover } from '@/components/ui/date-picker-popover'
import { ModelPicker } from '@/components/opencode/model-picker'
import { useUploadAttachment } from '@/hooks/use-task-attachments'

type TaskType = 'code' | 'quick'

function slugify(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
}

function generateBranchName(text: string): string {
  // Take only the first 4 words to keep worktree paths short
  const words = text.trim().split(/\s+/).slice(0, 4).join(' ')
  const slug = slugify(words)
  if (!slug) return ''
  const suffix = Math.random().toString(36).substring(2, 6)
  return `${slug}-${suffix}`
}

// Common fields needed for task creation from a repository
interface DefaultRepositoryProps {
  id: string
  path: string
  displayName: string
  startupScript?: string | null
  copyFiles?: string | null
  defaultAgent?: AgentType | null
  claudeOptions?: Record<string, string> | null
  opencodeOptions?: Record<string, string> | null
  opencodeModel?: string | null
}

interface CreateTaskModalProps {
  open?: boolean
  onOpenChange?: (open: boolean) => void
  defaultRepository?: DefaultRepositoryProps
  showTrigger?: boolean
}

export function CreateTaskModal({ open: controlledOpen, onOpenChange, defaultRepository, showTrigger = true }: CreateTaskModalProps = {}) {
  const { t } = useTranslation('tasks')
  const { t: tc } = useTranslation('common')
  const [internalOpen, setInternalOpen] = useState(false)

  // Support both controlled and uncontrolled modes
  const open = controlledOpen ?? internalOpen
  const setOpen = onOpenChange ?? setInternalOpen
  const [browserOpen, setBrowserOpen] = useState(false)
  const [title, setTitle] = useState('')
  const [description, setDescription] = useState('')
  const [taskType, setTaskType] = useState<TaskType>('code')
  const [labels, setLabels] = useState<string[]>([])
  const [labelInput, setLabelInput] = useState('')
  const [dueDate, setDueDate] = useState('')
  const [notes, setNotes] = useState('')
  const [repoPath, setRepoPath] = useState('')
  const [baseBranch, setBaseBranch] = useState('')
  const [branch, setBranch] = useState('')
  const [autoGeneratedBranch, setAutoGeneratedBranch] = useState('')
  const [aiMode, setAiMode] = useState<'default' | 'plan'>('default')
  const [aiModeManuallySet, setAiModeManuallySet] = useState(false)
  const [agent, setAgent] = useState<AgentType>('claude')
  const [selectedRepoId, setSelectedRepoId] = useState<string | null>(null)
  const [repoTab, setRepoTab] = useState<'saved' | 'browse'>('browse')
  const [repoSearchQuery, setRepoSearchQuery] = useState('')
  const [repoError, setRepoError] = useState<string | null>(null)
  const [isValidatingRepo, setIsValidatingRepo] = useState(false)
  const [opencodeModel, setOpencodeModel] = useState<string | null>(null)
  const [pendingFiles, setPendingFiles] = useState<File[]>([])
  const [selectedProjectId, setSelectedProjectId] = useState<string | null>(null)

  const navigate = useNavigate()
  const createTask = useCreateTask()
  const uploadAttachment = useUploadAttachment()
  const formRef = useRef<HTMLFormElement>(null)
  const attachmentInputRef = useRef<HTMLInputElement>(null)
  const { data: worktreeBasePath } = useWorktreeBasePath()
  const { data: defaultGitReposDir } = useDefaultGitReposDir()
  const { data: defaultAgent } = useDefaultAgent()
  const { data: globalOpencodeModel } = useOpencodeModel()
  const { data: repositories } = useRepositories()
  const { data: projects } = useProjects()
  const { data: branchData, isLoading: branchesLoading } = useBranches(
    repoPath || null
  )

  // Get the selected repository object
  const selectedRepo = selectedRepoId ? repositories?.find((r) => r.id === selectedRepoId) : null

  // Filter repositories based on search query (case-insensitive fuzzy match)
  const filteredRepositories = useMemo(() => {
    if (!repositories) return []
    // Don't filter when a repo is selected and the query matches its display name
    // This ensures all repos are shown in the dropdown when the modal opens
    if (selectedRepo && repoSearchQuery === selectedRepo.displayName) {
      return repositories
    }
    if (!repoSearchQuery.trim()) return repositories
    const query = repoSearchQuery.toLowerCase()
    return repositories.filter((repo) =>
      repo.displayName.toLowerCase().includes(query) ||
      repo.path.toLowerCase().includes(query)
    )
  }, [repositories, repoSearchQuery, selectedRepo])

  // Set default tab based on whether repositories exist
  useEffect(() => {
    if (repositories && repositories.length > 0) {
      setRepoTab('saved')
    } else {
      setRepoTab('browse')
    }
  }, [repositories])

  // Initialize with default repository when modal opens, or auto-select most recently used
  useEffect(() => {
    if (open) {
      // Determine which repository will be selected
      const selectedRepo = defaultRepository ?? (repositories && repositories.length > 0 ? repositories[0] : null)

      // Set agent priority: repository default > global default > 'claude'
      if (selectedRepo?.defaultAgent) {
        setAgent(selectedRepo.defaultAgent)
      } else if (defaultAgent) {
        setAgent(defaultAgent)
      }

      // Set OpenCode model: repository default > global default > null
      if (selectedRepo?.opencodeModel) {
        setOpencodeModel(selectedRepo.opencodeModel)
      } else if (globalOpencodeModel) {
        setOpencodeModel(globalOpencodeModel)
      } else {
        setOpencodeModel(null)
      }

      if (defaultRepository) {
        // Use provided default repository
        setSelectedRepoId(defaultRepository.id)
        setRepoPath(defaultRepository.path)
        setRepoSearchQuery(defaultRepository.displayName)
        setRepoTab('saved')
      } else if (repositories && repositories.length > 0) {
        // Auto-select first repository (most recently used due to sorting)
        const firstRepo = repositories[0]
        setSelectedRepoId(firstRepo.id)
        setRepoPath(firstRepo.path)
        setRepoSearchQuery(firstRepo.displayName)
        setRepoTab('saved')
      }
    }
  }, [open, defaultRepository, repositories, defaultAgent, globalOpencodeModel])

  // Set default base branch when branches are loaded, reset when repo changes
  useEffect(() => {
    if (branchData) {
      setBaseBranch(branchData.defaultBranch || branchData.branches[0] || 'main')
    } else {
      setBaseBranch('')
    }
  }, [branchData, repoPath])

  const handleTitleChange = (value: string) => {
    setTitle(value)
    // Generate a new auto-generated branch name when title changes
    setAutoGeneratedBranch(generateBranchName(value))
  }

  const handleRepoSelect = async (path: string) => {
    setRepoError(null)
    setIsValidatingRepo(true)

    try {
      const result = await checkIsGitRepo(path)

      if (!result.isGitRepo) {
        setRepoError(t('createModal.errors.notGitRepo'))
        setIsValidatingRepo(false)
        return
      }

      // Valid git repo - set the path
      setRepoPath(path)

      // Check if this path matches an existing saved repository
      const existingRepo = repositories?.find((r) => r.path === path)
      if (existingRepo) {
        // Use the existing repo's settings (copyFiles, startupScript, etc.)
        setSelectedRepoId(existingRepo.id)
      } else {
        // No saved repo found - task will work but without saved settings
        // User can create a project to save repository settings
        setSelectedRepoId(null)
      }
    } catch (err) {
      setRepoError(err instanceof Error ? err.message : t('createModal.errors.validationFailed'))
    } finally {
      setIsValidatingRepo(false)
    }
  }

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (!title.trim()) return

    // For code tasks, repo is required
    if (taskType === 'code' && !repoPath) return

    // Build the task payload based on type
    const isCodeTask = taskType === 'code'

    // Code task specific fields
    const repoName = isCodeTask ? (repoPath.split('/').pop() || 'repo') : null
    const effectiveBranch = isCodeTask ? (branch.trim() || autoGeneratedBranch) : null
    const worktreePath = isCodeTask && effectiveBranch ? `${worktreeBasePath}/${effectiveBranch}` : null

    // Select the appropriate agent options based on selected agent
    const agentOptions = agent === 'claude'
      ? selectedRepo?.claudeOptions
      : selectedRepo?.opencodeOptions

    createTask.mutate(
      {
        title: title.trim(),
        description: description.trim() || undefined,
        status: isCodeTask ? 'IN_PROGRESS' : 'TO_DO',
        agent,
        aiMode: isCodeTask ? aiMode : undefined,
        // Git fields - only for code tasks
        repoPath: isCodeTask ? repoPath : null,
        repoName: isCodeTask ? repoName : null,
        baseBranch: isCodeTask ? (baseBranch || 'main') : null,
        branch: isCodeTask ? effectiveBranch : null,
        worktreePath: isCodeTask ? worktreePath : null,
        copyFiles: isCodeTask ? (selectedRepo?.copyFiles || undefined) : undefined,
        startupScript: isCodeTask ? (selectedRepo?.startupScript || undefined) : undefined,
        agentOptions: isCodeTask ? (agentOptions || undefined) : undefined,
        opencodeModel: isCodeTask && agent === 'opencode' ? opencodeModel : undefined,
        // Generalized task fields
        labels: labels.length > 0 ? labels : undefined,
        dueDate: dueDate || null,
        notes: notes.trim() || null,
        projectId: !isCodeTask ? selectedProjectId : undefined,
      },
      {
        onSuccess: async (task) => {
          // Upload any pending attachments
          if (pendingFiles.length > 0) {
            for (const file of pendingFiles) {
              try {
                await uploadAttachment.mutateAsync({ taskId: task.id, file })
              } catch {
                // Continue with other files even if one fails
              }
            }
          }

          const navState = isCodeTask && description.trim()
            ? { aiMode, description: description.trim(), focusTerminal: true }
            : isCodeTask
            ? { aiMode, focusTerminal: true }
            : undefined
          setOpen(false)
          resetForm()
          navigate({ to: '/tasks/$taskId', params: { taskId: task.id }, state: navState as Record<string, unknown> })
        },
        onError: (error) => {
          toast.error(t('createModal.errors.createFailed'), {
            description: error instanceof Error ? error.message : String(error),
          })
        },
      }
    )
  }

  const resetForm = () => {
    setTitle('')
    setDescription('')
    setTaskType('code')
    setLabels([])
    setLabelInput('')
    setDueDate('')
    setNotes('')
    setPendingFiles([])
    setRepoPath('')
    setBaseBranch('')
    setBranch('')
    setAutoGeneratedBranch('')
    setAiMode('default')
    setAiModeManuallySet(false)
    setAgent(defaultAgent || 'claude')
    setOpencodeModel(null)
    setSelectedRepoId(null)
    setRepoSearchQuery('')
    setRepoError(null)
    setSelectedProjectId(null)
    // Reset tab to saved if repositories exist, otherwise browse
    setRepoTab(repositories && repositories.length > 0 ? 'saved' : 'browse')
  }

  const handleAddLabel = () => {
    const trimmed = labelInput.trim()
    if (trimmed && !labels.includes(trimmed)) {
      setLabels([...labels, trimmed])
      setLabelInput('')
    }
  }

  const handleRemoveLabel = (label: string) => {
    setLabels(labels.filter((l) => l !== label))
  }

  const handleLabelKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter') {
      e.preventDefault()
      handleAddLabel()
    } else if (e.key === 'Backspace' && !labelInput && labels.length > 0) {
      // Remove last label on backspace when input is empty
      setLabels(labels.slice(0, -1))
    }
  }

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files
    if (!files) return
    setPendingFiles(prev => [...prev, ...Array.from(files)])
    // Reset input so the same file can be selected again
    e.target.value = ''
  }

  const handleRemoveFile = (index: number) => {
    setPendingFiles(prev => prev.filter((_, i) => i !== index))
  }

  // Cmd+Enter to submit form when modal is open
  const canSubmit = !createTask.isPending && !!title.trim() && (taskType === 'quick' || !!repoPath)
  useHotkeys('meta+enter', () => {
    if (formRef.current) {
      formRef.current.requestSubmit()
    }
  }, {
    enabled: open && canSubmit,
    allowInInput: true,
    ignoreContext: true,
    deps: [open, canSubmit],
  })

  const effectiveBranch = branch.trim() || autoGeneratedBranch
  const displayWorktreePath = effectiveBranch
    ? `${worktreeBasePath}/${effectiveBranch}`
    : ''

  return (
    <>
      <Dialog open={open} onOpenChange={setOpen}>
        {showTrigger && (
          <DialogTrigger render={<Button size="sm" />}>
            <HugeiconsIcon icon={TaskAdd01Icon} size={16} strokeWidth={2} data-slot="icon" className="-translate-y-px" />
            {t('newTask')}
          </DialogTrigger>
        )}
        <DialogContent className="sm:max-w-md max-h-[80dvh] flex flex-col overflow-hidden">
          <form ref={formRef} onSubmit={handleSubmit} className="flex flex-col min-h-0 flex-1">
            <DialogHeader className="shrink-0">
              <DialogTitle>{t('createModal.title')}</DialogTitle>
              <DialogDescription>
                {t('createModal.description')}
              </DialogDescription>
            </DialogHeader>

            <FieldGroup className="mt-4 pb-4 overflow-y-auto min-h-0 flex-1">
              <Field>
                <FieldLabel htmlFor="title">{t('createModal.fields.title')}</FieldLabel>
                <Input
                  id="title"
                  value={title}
                  onChange={(e) => handleTitleChange(e.target.value)}
                  placeholder={t('createModal.fields.titlePlaceholder')}
                  required
                />
              </Field>

              <Field>
                <FieldLabel htmlFor="description">{t('createModal.fields.description')}</FieldLabel>
                <DescriptionTextarea
                  id="description"
                  value={description}
                  onValueChange={(value) => {
                    setDescription(value)
                    // Auto-switch AI mode based on description content (unless manually set)
                    if (!aiModeManuallySet && taskType === 'code') {
                      setAiMode(value.trim() ? 'plan' : 'default')
                    }
                  }}
                  placeholder={t('createModal.fields.descriptionPlaceholder')}
                  rows={2}
                />
              </Field>

              {/* Task Type Toggle */}
              <Field>
                <FieldLabel>Task Type</FieldLabel>
                <ToggleGroup
                  value={[taskType]}
                  onValueChange={(value) => {
                    const selected = Array.isArray(value) ? value[0] : value
                    if (selected) setTaskType(selected as TaskType)
                  }}
                  className="w-full"
                  variant="outline"
                >
                  <ToggleGroupItem value="code" className="flex-1">Code Task</ToggleGroupItem>
                  <ToggleGroupItem value="quick" className="flex-1">Quick Task</ToggleGroupItem>
                </ToggleGroup>
                <FieldDescription>
                  {taskType === 'code'
                    ? 'Creates a git worktree and opens an AI coding agent.'
                    : 'Creates a task without code context. You can add code later.'}
                </FieldDescription>
              </Field>

              {/* Project selector for quick tasks */}
              {taskType === 'quick' && (
                <Field>
                  <FieldLabel>Project (optional)</FieldLabel>
                  <Select
                    value={selectedProjectId || '_none'}
                    onValueChange={(value) => setSelectedProjectId(value === '_none' ? null : value)}
                  >
                    <SelectTrigger className="w-full">
                      <SelectValue>
                        {selectedProjectId
                          ? projects?.find((p) => p.id === selectedProjectId)?.name || 'Select project'
                          : 'No project (Inbox)'}
                      </SelectValue>
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="_none">No project (Inbox)</SelectItem>
                      {projects?.map((project) => (
                        <SelectItem key={project.id} value={project.id}>
                          {project.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  <FieldDescription>
                    Tasks without a project appear in the Inbox.
                  </FieldDescription>
                </Field>
              )}

              {taskType === 'code' && (
                <>
              <Field>
                <FieldLabel>{t('createModal.fields.aiMode')}</FieldLabel>
                <ToggleGroup
                  value={[aiMode]}
                  onValueChange={(value) => {
                    const selected = Array.isArray(value) ? value[0] : value
                    if (selected) {
                      setAiMode(selected as 'default' | 'plan')
                      setAiModeManuallySet(true)
                    }
                  }}
                  className="w-full"
                  variant="outline"
                >
                  <ToggleGroupItem value="plan" className="flex-1">{t('createModal.aiModes.plan')}</ToggleGroupItem>
                  <ToggleGroupItem value="default" className="flex-1">{t('createModal.aiModes.default')}</ToggleGroupItem>
                </ToggleGroup>
              </Field>

              <Field>
                <FieldLabel>{t('createModal.fields.agent')}</FieldLabel>
                <Select value={agent} onValueChange={(value) => setAgent(value as AgentType)}>
                  <SelectTrigger className="w-full">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    {(Object.keys(AGENT_DISPLAY_NAMES) as AgentType[]).map((agentType) => (
                      <SelectItem key={agentType} value={agentType}>
                        {AGENT_DISPLAY_NAMES[agentType]}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </Field>

              {agent === 'opencode' && (
                <Field>
                  <FieldLabel>{t('createModal.fields.opencodeModel')}</FieldLabel>
                  <ModelPicker
                    value={opencodeModel}
                    onChange={setOpencodeModel}
                    placeholder={t('createModal.fields.opencodeModelPlaceholder')}
                  />
                </Field>
              )}

              <Field>
                <FieldLabel>{t('createModal.fields.repository')}</FieldLabel>
                <Tabs
                  value={repoTab}
                  onValueChange={(v) => {
                    setRepoTab(v as 'saved' | 'browse')
                    setRepoError(null)
                  }}
                >
                  <TabsList>
                    <TabsTrigger value="saved" disabled={!repositories?.length}>
                      {t('createModal.tabs.saved')}
                    </TabsTrigger>
                    <TabsTrigger value="browse">{t('createModal.tabs.browse')}</TabsTrigger>
                  </TabsList>

                  <TabsContent value="saved" className="mt-2">
                    <Combobox
                      value={selectedRepoId || ''}
                      onValueChange={(id) => {
                        const repo = repositories?.find((r) => r.id === id)
                        if (repo) {
                          setSelectedRepoId(id as string)
                          setRepoPath(repo.path)
                          setRepoSearchQuery(repo.displayName)
                          setRepoError(null)
                          // Update agent if repository has a default configured
                          if (repo.defaultAgent) {
                            setAgent(repo.defaultAgent)
                          }
                          // Update OpenCode model: repo default > global default
                          setOpencodeModel(repo.opencodeModel ?? globalOpencodeModel ?? null)
                        }
                      }}
                      inputValue={repoSearchQuery}
                      onInputValueChange={(value) => {
                        setRepoSearchQuery(value)
                        // Don't clear selection when typing - user must explicitly select
                        // This ensures startupScript/copyFiles are preserved from the selected repo
                      }}
                      itemToStringLabel={(id) =>
                        repositories?.find((r) => r.id === id)?.displayName || ''
                      }
                    >
                      <ComboboxInput
                        placeholder={t('createModal.searchRepositories')}
                        className="w-full"
                      />
                      <ComboboxContent>
                        <ComboboxList>
                          <ComboboxEmpty>{t('createModal.noRepositoriesFound')}</ComboboxEmpty>
                          {filteredRepositories.map((repo) => (
                            <ComboboxItem key={repo.id} value={repo.id}>
                              {repo.displayName}
                            </ComboboxItem>
                          ))}
                        </ComboboxList>
                      </ComboboxContent>
                    </Combobox>
                  </TabsContent>

                  <TabsContent value="browse" className="mt-2">
                    <Button
                      type="button"
                      variant="outline"
                      className="w-full justify-start font-normal"
                      onClick={() => setBrowserOpen(true)}
                      disabled={isValidatingRepo}
                    >
                      <HugeiconsIcon
                        icon={Folder01Icon}
                        size={14}
                        strokeWidth={2}
                        className="mr-2"
                      />
                      {isValidatingRepo ? (
                        <span className="text-muted-foreground">{tc('status.validating')}</span>
                      ) : repoPath && !selectedRepoId ? (
                        <span className="truncate">{repoPath}</span>
                      ) : (
                        <span className="text-muted-foreground group-hover/button:text-accent-foreground">{t('createModal.selectFolder')}</span>
                      )}
                    </Button>
                  </TabsContent>
                </Tabs>

                {repoError && (
                  <p className="text-sm text-destructive">{repoError}</p>
                )}

                {repoPath && !repoError && (
                  <FieldDescription className="font-mono text-xs truncate">
                    {repoPath}
                  </FieldDescription>
                )}
              </Field>

              <Field>
                <FieldLabel htmlFor="baseBranch">{t('createModal.fields.baseBranch')}</FieldLabel>
                <Select
                  value={baseBranch}
                  onValueChange={(value) => setBaseBranch(value ?? '')}
                  disabled={!repoPath || branchesLoading}
                >
                  <SelectTrigger className="w-full">
                    <SelectValue>
                      {baseBranch || (
                        <span className="text-muted-foreground">
                          {!repoPath
                            ? t('createModal.selectRepositoryFirst')
                            : branchesLoading
                            ? t('createModal.loadingBranches')
                            : t('createModal.selectBranch')}
                        </span>
                      )}
                    </SelectValue>
                  </SelectTrigger>
                  <SelectContent>
                    {branchData?.branches.map((b) => (
                      <SelectItem key={b} value={b}>
                        {b}
                        {b === branchData.current && (
                          <span className="text-muted-foreground ml-2">{t('createModal.current')}</span>
                        )}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </Field>

              <Field>
                <FieldLabel htmlFor="branch">{t('createModal.fields.branchName')}</FieldLabel>
                <Input
                  id="branch"
                  value={branch}
                  onChange={(e) => setBranch(e.target.value)}
                  placeholder={autoGeneratedBranch || t('createModal.fields.branchPlaceholder')}
                />
                {displayWorktreePath && (
                  <FieldDescription>
                    {t('createModal.worktreePrefix')} {displayWorktreePath}
                  </FieldDescription>
                )}
                {!branch.trim() && autoGeneratedBranch && (
                  <FieldDescription>
                    {t('createModal.branchAutoGenerated', { branch: autoGeneratedBranch })}
                  </FieldDescription>
                )}
              </Field>
                </>
              )}

              {/* Labels and Due Date row - always at bottom */}
              <div className="flex gap-3">
                <Field className="flex-1">
                  <FieldLabel htmlFor="labels">Labels</FieldLabel>
                  <div className="flex flex-wrap items-center gap-1 rounded-md border border-input bg-background px-2 py-1.5 min-h-[36px]">
                    {labels.map((label) => (
                      <span
                        key={label}
                        className="inline-flex items-center gap-0.5 rounded border border-border bg-card px-1.5 py-0.5 text-xs font-medium"
                      >
                        {label}
                        <button
                          type="button"
                          onClick={() => handleRemoveLabel(label)}
                          className="text-muted-foreground hover:text-foreground"
                        >
                          <HugeiconsIcon icon={Cancel01Icon} size={10} />
                        </button>
                      </span>
                    ))}
                    <input
                      id="labels"
                      type="text"
                      value={labelInput}
                      onChange={(e) => setLabelInput(e.target.value)}
                      onKeyDown={handleLabelKeyDown}
                      onBlur={handleAddLabel}
                      placeholder={labels.length === 0 ? 'Add labels...' : ''}
                      className="flex-1 min-w-[60px] bg-transparent text-sm outline-none placeholder:text-muted-foreground"
                    />
                  </div>
                </Field>

                <Field className="w-40">
                  <FieldLabel>Due Date</FieldLabel>
                  <DatePickerPopover
                    value={dueDate || null}
                    onChange={(date) => setDueDate(date || '')}
                    placeholder="Set date"
                    showClear
                    className="border border-input rounded-md px-3 py-2 w-full justify-start"
                  />
                </Field>
              </div>

              {/* Notes */}
              <Field>
                <FieldLabel htmlFor="notes">Notes</FieldLabel>
                <textarea
                  id="notes"
                  value={notes}
                  onChange={(e) => setNotes(e.target.value)}
                  placeholder="Add notes..."
                  rows={2}
                  className="w-full rounded-md border border-input bg-background px-3 py-2 text-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring resize-none"
                />
              </Field>

              {/* Attachments */}
              <Field>
                <FieldLabel>Attachments</FieldLabel>
                <div className="space-y-2">
                  <input
                    ref={attachmentInputRef}
                    type="file"
                    multiple
                    className="hidden"
                    onChange={handleFileSelect}
                    accept=".pdf,.png,.jpg,.jpeg,.gif,.webp,.svg,.txt,.md,.doc,.docx,.xls,.xlsx,.csv"
                  />
                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    className="w-full justify-start text-muted-foreground"
                    onClick={() => attachmentInputRef.current?.click()}
                  >
                    <HugeiconsIcon icon={Attachment01Icon} size={14} className="mr-2" />
                    {pendingFiles.length === 0 ? 'Add attachments...' : 'Add more files...'}
                  </Button>
                  {pendingFiles.length > 0 && (
                    <div className="flex flex-wrap gap-1">
                      {pendingFiles.map((file, index) => (
                        <span
                          key={`${file.name}-${index}`}
                          className="inline-flex items-center gap-0.5 rounded border border-border bg-card px-1.5 py-0.5 text-xs font-medium"
                        >
                          {file.name}
                          <button
                            type="button"
                            onClick={() => handleRemoveFile(index)}
                            className="text-muted-foreground hover:text-foreground"
                          >
                            <HugeiconsIcon icon={Cancel01Icon} size={10} />
                          </button>
                        </span>
                      ))}
                    </div>
                  )}
                </div>
              </Field>
            </FieldGroup>

            <DialogFooter className="mt-4 shrink-0">
              <DialogClose render={<Button variant="outline" type="button" className="border-destructive text-destructive hover:bg-destructive hover:text-white" />}>
                {tc('buttons.cancel')}
              </DialogClose>
              <Button
                type="submit"
                disabled={!canSubmit}
              >
                {createTask.isPending ? tc('status.creating') : t('createModal.createTask')}
              </Button>
            </DialogFooter>
          </form>
        </DialogContent>
      </Dialog>

      <FilesystemBrowser
        open={browserOpen}
        onOpenChange={setBrowserOpen}
        onSelect={handleRepoSelect}
        initialPath={defaultGitReposDir || undefined}
      />
    </>
  )
}
